## Chapter 01

### 01 티켓 판매 애플리케이션 구현하기

- 소극장 홍보 겸 관람객들의 발길이 이어지도록 작은 이벤트 기획.
- 간단한 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장 발송
- 이벤트에 당첨된 관람객과 그렇지 못한 관람객은 다른 방식으로 입장
- 이벤트 당첨된 관람객은 초대장을 티켓으로 교환한 후 입장
- 관람객을 입장시키기전에 입네트 당첨 여부를 확인.
- 이벤트 당첨자가 아닌 경우에는 티켓을 판매한 후 입장.

### sub01의 문제점
- 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재.
- 관람객의 입장에서 문제는 소극장이라는 제3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어 본다는 데 있다.
- 소극장이 판매원의 허락도 업싱 매표소에 보관 중인 티켓과 현금에 마음대로 접근할 수 있다.
- 티켓을 꺼내 관람객의 가방에 집어넣고 관람객에서 받은 돈을 매표소에 적립하는 일은 판매원이 아닌 소극장이 수행한다.
- 이 코드를 이해하기 위해서는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다.

### 변경에 취약한 코드
- 관람객이 가방을 들고 있지 않다면 어떻게 해야 하는가?
- 관람객이 현금이 아니라 신용카드를 이용해서 결제 한다면 어떻게 해야 할까?
- 판매원이 매표소 밖에서 티켓을 판매해야 한다면 어떻게 해야 할까?
- 관람객이 가방을 들고 있다는 가정이 바뀐다면, Audience 클래스에서 Bag을 제거해야 할 뿐만 아니라 Bag에 접근하는 메서드 역시 수정 되어야 한다.
- 이것을 객체 사이의 의존성(Dependency)과 관련된 문제이며, 의존성이 변경과 관련돼 있다는 점
- 객체 사이에 의존성이 과한 경우를 가리켜 결합도(coupling)이 높다고 말한다.
- 결합도는 의존성과 관련돼 있기 때문에 결합도 역시 변경과 관련이 있다.
- 따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것.

### 설계 개선하기
자율성을 높이자
- 설계를 변경하기 어려운 이유는 Theater가 Audience와 TicketSeller뿐만 아니라 Audience 소유의 Bag과 
TicketSeller가 근무하는 TicketOffice까지 마음대로 접근할 수 있기 때문이다.
    - 해결 방법은 Audience와 TicketSeller가 직접 하위 객체를 처리하는 자율적인 존재가 되도록 설계를 변경하는 것
    - Theater의 enter메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기는 것.
    - TicketSeller에 sellTo 메서드를 추가하고 Theater에 있던 로직을 이 메서드로 옮기자.
- TicketSeller에서 getTicketOffice 메서드가 되었으며, ticketOffice의 가시성이 private이고 접근 가능한 퍼블릭 메서드가 존재하지 않기 때문에 외부에서는 ticketOffice에 직접 접근할 수 없다.
    - 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화(encapsulation)라고 부른다.
    - 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것
    - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다

### 어떻게 한 것인가
- 판매자가 티켓을 판매하기 위해 TicketOffice를 사용하는 모든 부분은 TicketSeller 내부로 옮기고,
- 관람객이 티켓을 구매하기 위해 Bag을 사용하는 모든 부분을 Audience 내부로 옮긴 것.
- 다시 말해 자기 자신의 문제를 스스로 해결하도록 코드를 변경.

### 캡슐화와 응집도
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.
- 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.
- 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다. 그것이 객체의 응집도를 높이는 첫 걸음이다.

